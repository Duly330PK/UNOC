<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>UNOC - Unified NOC UI</title>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --header-bg: #2a2a2a;
            --panel-bg: #242424;
            --border-color: #444;
            --text-color: #e0e0e0;
            --text-muted: #aaa;
            --accent-color: #4CAF50;
            --accent-red: #F44336;
            --accent-green: #4CAF50;
        }

        body, html {
            margin: 0; padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color); color: var(--text-color);
            height: 100vh; overflow: hidden; display: flex; flex-direction: column;
        }

        header {
            background-color: var(--header-bg);
            padding: 10px 20px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        main {
            display: flex;
            flex-grow: 1;
            height: calc(100% - 100px);
        }

        h1, h2 {
            margin: 0; padding: 0; font-weight: 500;
        }

        #network-container {
            width: 75%; height: 100%;
            border-right: 1px solid var(--border-color);
        }

        #sidebar {
            width: 25%; height: 100%;
            display: flex; flex-direction: column;
            background-color: var(--panel-bg);
        }

        .panel {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            overflow-y: auto;
        }

        .panel h2 {
            margin-bottom: 10px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        #scenario-panel, #snapshot-panel, #controls-panel, #cli-panel {
            flex-shrink: 0;
        }

        #properties-panel {
            flex-grow: 1;
        }

        #events-panel {
            height: 35%; flex-shrink: 0;
        }

        #event-log {
            list-style: none; padding: 0; margin: 0;
            font-family: monospace; font-size: 12px;
        }

        #event-log li {
            padding: 4px 0; border-bottom: 1px solid #333;
        }

        #event-log li:first-child {
            color: var(--accent-color);
        }

        .loader {
            color: var(--text-muted); font-style: italic;
        }

        input, button, select {
            width: calc(100% - 10px);
            padding: 8px 5px;
            margin-bottom: 10px;
            border-radius: 3px;
            border: 1px solid #666;
            background-color: #333;
            color: var(--text-color);
            font-size: 14px;
        }

        button {
            cursor: pointer;
            background-color: #007BFF;
            border-color: #007BFF;
            font-weight: bold;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #555;
            border-color: #666;
            cursor: not-allowed;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        #hud {
            display: flex;
            justify-content: space-around;
            background-color: #2c2c2c;
            padding: 10px;
            border-bottom: 1px solid #444;
        }

        .hud-item {
            text-align: center;
        }

        .hud-item h3 {
            margin: 0;
            font-size: 14px;
            color: #aaa;
        }

        .hud-item p {
            margin: 0;
            font-size: 20px;
            font-weight: bold;
        }

        #properties-content table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        #properties-content th, #properties-content td {
            padding: 4px 8px;
            text-align: left;
            border-bottom: 1px solid #333;
        }

        #cli-panel {
            padding: 10px;
            border-top: 1px solid #444;
        }

        #cli-input {
            width: calc(100% - 20px);
            background-color: #111;
            border: 1px solid #555;
            color: #00ff00;
            font-family: monospace;
            padding: 8px;
        }
        
        /* NEUE STILE FÜR RING-PANEL */
        #ring-panel table { width: 100%; text-align: left; border-collapse: collapse; }
        #ring-panel td { padding: 4px 2px; }
        #ring-panel .status-blocking { color: #FFC107; font-weight: bold; }
        #ring-panel .status-forwarding { color: var(--accent-green); font-weight: bold; }
    </style>
</head>
<body>
    <header><h1>UNOC - Netzwerk Visualisierung</h1></header>

    <div id="hud">
        <div class="hud-item"><h3>Geräte Online</h3><p id="hud-devices">...</p></div>
        <div class="hud-item"><h3>Links Up</h3><p id="hud-links">...</p></div>
        <div class="hud-item"><h3>Alarme</h3><p id="hud-alarms">...</p></div>
    </div>

    <main>
        <div id="network-container"></div>
        <aside id="sidebar">
            <!-- NEUES PANEL FÜR RINGE -->
            <div id="ring-panel" class="panel">
                <h2>Ring Status</h2>
                <div id="ring-info" class="loader">Lade Ring-Status...</div>
            </div>
            
            <div id="properties-panel" class="panel">
                <h2>Eigenschaften</h2>
                <div id="properties-content" class="loader">Kein Element ausgewählt</div>
            </div>

            <div id="controls-panel" class="panel">
                <h2>Steuerung</h2>
                <div class="button-group">
                    <button id="undo-btn" disabled>Undo</button>
                    <button id="redo-btn" disabled>Redo</button>
                </div>
            </div>

            <div id="scenario-panel" class="panel">
                <h2>Szenarien</h2>
                <select id="splitter-select"></select>
                <button id="fiber-cut-btn">Faserschnitt simulieren</button>
            </div>

            <div id="snapshot-panel" class="panel">
                <h2>Snapshots</h2>
                <input type="text" id="snapshot-name" placeholder="Snapshot-Name eingeben...">
                <div class="button-group">
                    <button id="save-snapshot-btn">Speichern</button>
                    <button id="load-snapshot-btn">Laden</button>
                </div>
            </div>

            <div id="events-panel" class="panel">
                <h2>Event Log</h2>
                <ul id="event-log"><li class="loader">Lade Events...</li></ul>
            </div>

            <div id="cli-panel">
                <input type="text" id="cli-input" placeholder="[CLI]> z.B. link-down link-01">
            </div>
        </aside>
    </main>

    <script>
        const backendUrl = "http://127.0.0.1:5000";
        let network = null;
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        let eventPollInterval = null;

        const statusToColor = {
            online: { border: "#4CAF50", background: "#2e7d32" },
            offline: { border: "#F44336", background: "#c62828" },
            maintenance: { border: "#FFC107", background: "#ffa000" },
            up: { color: "#4CAF50", highlight: "#66BB6A" },
            down: { color: "#F44336", highlight: "#EF5350" },
            degraded: { color: "#FFC107", highlight: "#FFCA28" },
            // NEU: Visualisierung für 'blocking'
            blocking: { color: "#FFC107", highlight: "#FFCA28" }
        };

        function formatDeviceToNode(d) {
            return {
                id: d.id, label: `${d.type}\n(${d.id})`, shape: 'box',
                color: statusToColor[d.status], font: { color: '#ffffff' }, data: d
            };
        }

        function formatLinkToEdge(l) {
            const edge = {
                id: l.id, from: l.source, to: l.target,
                color: statusToColor[l.status],
                arrows: 'to, from',
                data: l
            };
            // Gestichelte Linie für blockierte Links
            if (l.status === 'blocking') {
                edge.dashes = [5, 5];
            }
            return edge;
        }
        
        // NEUE Funktion, um Ring-Panel zu aktualisieren
        function updateRingPanel(topology) {
            const ringInfoDiv = document.getElementById('ring-info');
            if (!topology.rings || topology.rings.length === 0) {
                ringInfoDiv.innerHTML = '<span class="loader">Keine Ringe definiert.</span>';
                return;
            }
            let html = '<table>';
            topology.rings.forEach(ring => {
                const rpl = topology.links.find(l => l.id === ring.rpl_link_id);
                if (rpl) {
                    const statusClass = rpl.status === 'blocking' ? 'status-blocking' : 'status-forwarding';
                    html += `<tr><td><b>${ring.name}</b></td><td class="${statusClass}">${rpl.status.toUpperCase()}</td></tr>`;
                }
            });
            html += '</table>';
            ringInfoDiv.innerHTML = html;
        }

        async function initializeNetwork() {
            try {
                const response = await fetch(`${backendUrl}/api/topology`);
                const topology = await response.json();

                nodes.clear(); edges.clear();
                nodes.add(topology.devices.map(formatDeviceToNode));
                edges.add(topology.links.map(formatLinkToEdge));

                populateSplitterDropdown(topology.devices);
                updateRingPanel(topology); // Ring-Panel initial befüllen

                if (!network) {
                    const container = document.getElementById('network-container');
                    const data = { nodes, edges };
                    network = new vis.Network(container, data, {});
                    setupEventListeners();
                }

                if (!eventPollInterval) {
                    eventPollInterval = setInterval(pollForUpdates, 2000);
                }
            } catch (e) {
                console.error("Fehler:", e);
            }
        }

        function populateSplitterDropdown(devices) {
            const select = document.getElementById('splitter-select');
            select.innerHTML = '';
            devices.filter(d => d.type.toLowerCase() === 'splitter')
                   .forEach(d => {
                       const option = document.createElement('option');
                       option.value = d.id;
                       option.textContent = d.id;
                       select.appendChild(option);
                   });
        }

        function renderProperties(data) {
            const content = document.getElementById('properties-content');
            if (!data) return content.innerHTML = '<span class="loader">Kein Element ausgewählt</span>';
            let table = '<table>';
            for (const [k, v] of Object.entries(data)) {
                table += `<tr><th>${k}</th><td>${typeof v === 'object' ? JSON.stringify(v) : v}</td></tr>`;
            }
            table += '</table>';
            content.innerHTML = table;
        }

        function setupEventListeners() {
            network.on('click', (params) => {
                const data = params.nodes.length ? nodes.get(params.nodes[0]).data :
                             params.edges.length ? edges.get(params.edges[0]).data : null;
                renderProperties(data);
            });

            document.getElementById('undo-btn').onclick = undoAction;
            document.getElementById('redo-btn').onclick = redoAction;
            document.getElementById('fiber-cut-btn').onclick = simulateFiberCut;
            document.getElementById('save-snapshot-btn').onclick = saveSnapshot;
            document.getElementById('load-snapshot-btn').onclick = loadSnapshot;
            document.getElementById('cli-input').addEventListener('keydown', handleCliCommand);
        }

        async function postAction(endpoint, payload = {}) {
            const res = await fetch(`${backendUrl}${endpoint}`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!res.ok) throw new Error((await res.json()).description || "Fehler");
            // Warten auf das nächste Poll-Intervall ist oft ausreichend,
            // aber für eine sofortige Reaktion rufen wir es direkt auf.
            await pollForUpdates();
        }

        async function undoAction() { await postAction('/api/simulation/undo'); }
        async function redoAction() { await postAction('/api/simulation/redo'); }
        async function simulateFiberCut() {
            const nodeId = document.getElementById('splitter-select').value;
            if (!nodeId) return alert("Splitter auswählen.");
            if (confirm(`Faserschnitt bei ${nodeId}?`)) await postAction('/api/simulation/fiber-cut', { node_id: nodeId });
        }

        async function pollForUpdates() {
            try {
                // Events und History-Status parallel abfragen
                const [eventsRes, historyRes, statsRes] = await Promise.all([
                    fetch(`${backendUrl}/api/events`),
                    fetch(`${backendUrl}/api/history/status`),
                    fetch(`${backendUrl}/api/topology/stats`)
                ]);
                
                const events = await eventsRes.json();
                const historyStatus = await historyRes.json();
                const stats = await statsRes.json();

                // Event-Log nur bei Änderung aktualisieren
                const eventLog = document.getElementById('event-log');
                if (events[0] !== eventLog.children[0]?.textContent) {
                    eventLog.innerHTML = events.map(e => `<li>${e}</li>`).join('');
                    // Nur wenn sich Events geändert haben, hat sich wahrscheinlich auch die Topologie geändert
                    await refreshTopologyDisplay();
                }

                // HUD und Buttons immer aktualisieren
                updateHud(stats);
                updateHistoryButtons(historyStatus);

            } catch (error) {
                console.error("Polling-Fehler:", error);
            }
        }

        function updateHud(stats) {
            document.getElementById('hud-devices').textContent = `${stats.devices_online} / ${stats.devices_total}`;
            document.getElementById('hud-links').textContent = `${stats.links_up} / ${stats.links_total}`;
            const alarms = document.getElementById('hud-alarms');
            alarms.textContent = stats.alarms;
            alarms.style.color = stats.alarms > 0 ? 'var(--accent-red)' : 'var(--accent-green)';
        }

        function updateHistoryButtons(status) {
            document.getElementById('undo-btn').disabled = !status.can_undo;
            document.getElementById('redo-btn').disabled = !status.can_redo;
        }

        async function refreshTopologyDisplay() {
            try {
                const res = await fetch(`${backendUrl}/api/topology`);
                if (!res.ok) return;
                const topology = await res.json();
                nodes.update(topology.devices.map(formatDeviceToNode));
                edges.update(topology.links.map(formatLinkToEdge));
                updateRingPanel(topology); // NEU: Ring-Panel bei Refresh aufrufen
            } catch (error) { console.error("Fehler bei Topologie-Aktualisierung:", error); }
        }

        async function saveSnapshot() {
            const name = document.getElementById('snapshot-name').value;
            if (!name) return alert("Name fehlt.");
            await postAction('/api/snapshot/save', { name });
        }

        async function loadSnapshot() {
            const name = document.getElementById('snapshot-name').value;
            if (!name || !confirm(`Snapshot '${name}' laden?`)) return;
            await postAction('/api/snapshot/load', { name });
        }

        async function handleCliCommand(event) {
            if (event.key !== 'Enter') return;
            const input = event.target.value.trim();
            if (!input) return;
            event.target.value = '';
            
            const [command, ...args] = input.split(' ');
            const arg = args.join(' ');

            try {
                if (command === "undo") return await undoAction();
                if (command === "redo") return await redoAction();
                if (command === "cut" || command === "fiber-cut") return await postAction('/api/simulation/fiber-cut', { node_id: arg });
                if (command.startsWith("link-")) return await postAction(`/api/links/${arg}/status`, { status: command.split("-")[1] });
                alert(`Unbekannter Befehl: ${command}`);
            } catch (error) {
                console.error("CLI Error:", error);
                alert(error.message);
            }
        }

        document.addEventListener('DOMContentLoaded', initializeNetwork);
    </script>
</body>
</html>
