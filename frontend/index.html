<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>UNOC - Unified NOC UI</title>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --header-bg: #2a2a2a;
            --panel-bg: #242424;
            --border-color: #444;
            --text-color: #e0e0e0;
            --text-muted: #aaa;
            --accent-color: #4CAF50;
            --accent-red: #F44336;
            --accent-green: #4CAF50;
            --accent-blue-highlight: #00BFFF;
            --font-size-normal: 14px;
            --font-size-large: 16px;
        }
        body, html {
            margin: 0; padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color); color: var(--text-color);
            height: 100vh; overflow: hidden; display: flex; flex-direction: column;
        }
        header {
            background-color: var(--header-bg);
            padding: 10px 20px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        h1 { font-size: 1.5em; }
        h2 { font-size: 1.2em; border-bottom: 1px solid #555; padding-bottom: 8px; margin: 0 0 12px 0; }
        
        main {
            display: flex;
            flex-grow: 1;
            height: calc(100% - 100px);
        }
        
        #left-sidebar {
            width: 25%;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            background-color: var(--panel-bg);
        }
        #center-column {
            width: 50%;
            display: flex;
            flex-direction: column;
        }
        #right-sidebar {
            width: 25%;
            display: flex;
            flex-direction: column;
            background-color: var(--panel-bg);
            border-left: 1px solid var(--border-color);
        }

        #view-container {
            height: 70%;
            position: relative;
            border-bottom: 1px solid var(--border-color);
        }
        #event-log-panel {
            height: 30%;
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #network-container, #map-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--bg-color);
        }
        #map-container { z-index: 10; visibility: hidden; }
        #view-toggle {
            position: absolute; top: 10px; right: 10px; z-index: 20;
        }
        #view-toggle button {
            width: auto; padding: 8px 12px; background-color: rgba(42, 42, 42, 0.8);
        }
        
        .panel {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            overflow-y: auto;
            font-size: var(--font-size-normal);
        }
        #properties-panel, #event-log, #cli-panel { flex-grow: 1; }
        
        #event-log {
            overflow-y: auto;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.4;
            list-style: none; padding: 0; margin: 0; 
        }
        #event-log li { padding: 4px 0; border-bottom: 1px solid #333; }
        #event-log li:first-child { color: var(--accent-color); }
        
        #cli-panel {
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow: visible;
        }
        #cli-output {
            flex-grow: 1;
            overflow-y: auto;
            font-family: monospace;
            font-size: 13px;
            line-height: 1.4;
            margin-top: 15px;
        }
        #cli-interaction-area {
            position: relative;
        }
        #cli-input-wrapper {
            display: flex;
            align-items: center;
        }
        #cli-prompt { font-family: monospace; padding-right: 8px; font-size: var(--font-size-large); color: var(--text-muted); }
        #cli-input {
            flex-grow: 1;
            background-color: #2c2c2c;
            border: 1px solid #555;
            color: #00ff00;
            font-family: monospace;
            font-size: var(--font-size-large);
            padding: 8px;
            margin: 0;
            border-radius: 3px;
        }
        #cli-input:focus { outline: none; border-color: var(--accent-blue-highlight); }
        
        #cli-suggestions {
            position: absolute;
            top: 100%; 
            left: 0;
            right: 0;
            max-height: 150px;
            overflow-y: auto;
            background-color: #2c2c2c;
            border: 1px solid #555;
            border-top: none;
            z-index: 1000;
        }
        .suggestion-item { padding: 8px 12px; cursor: pointer; color: #ddd; font-family: monospace; }
        .suggestion-item:hover, .suggestion-item.active { background-color: #007BFF; color: white; }
        
        input, button, select {
            padding: 10px; margin-bottom: 10px; border-radius: 4px;
            border: 1px solid #666; background-color: #333;
            color: var(--text-color); font-size: var(--font-size-normal);
        }
        select { width: 100%; }
        .button-group { display: flex; gap: 10px; flex-wrap: wrap; }
        .input-group { display: flex; gap: 10px; }
        .input-group input { flex-grow: 1; margin-bottom: 0; }
        .input-group button { margin-bottom: 0; }
        button { cursor: pointer; background-color: #007BFF; border-color: #007BFF; font-weight: bold; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #555; border-color: #666; cursor: not-allowed; }
        
        #hud { display: flex; justify-content: space-around; background-color: #2c2c2c; padding: 10px; border-bottom: 1px solid #444; flex-shrink: 0; }
        .hud-item { text-align: center; }
        .hud-item h3 { margin: 0; font-size: 14px; color: #aaa; text-transform: uppercase; }
        .hud-item p { margin: 5px 0 0; font-size: 22px; font-weight: bold; }
        
        #properties-content table, #ring-info table { width: 100%; border-collapse: collapse; font-size: var(--font-size-normal); }
        #properties-content th, #properties-content td, #ring-info td { padding: 8px; text-align: left; border-bottom: 1px solid #333; }
        #properties-content th { width: 35%; color: var(--text-muted); }
        
        #ring-panel .status-blocking { color: #FFC107; font-weight: bold; }
        #ring-panel .status-forwarding { color: var(--accent-green); font-weight: bold; }
        
        .loader { color: var(--text-muted); font-style: italic; }
        .signal-good { color: var(--accent-green); font-weight: bold; }
        .signal-warning { color: #FFC107; font-weight: bold; }
        .signal-los { color: var(--accent-red); font-weight: bold; }
        
        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.7); z-index: 1000;
            display: flex; justify-content: center; align-items: center;
        }
        #modal-overlay.hidden { display: none; }
        #modal-box {
            background-color: var(--panel-bg); padding: 25px; border-radius: 8px;
            border: 1px solid var(--border-color); width: 90%; max-width: 500px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        #modal-box h2 { margin-top: 0; border-bottom: none; }
        #modal-message { font-size: var(--font-size-normal); line-height: 1.5; }
        #modal-buttons { margin-top: 20px; display: flex; justify-content: flex-end; gap: 10px; }
        #modal-buttons button { margin-bottom: 0; }
        .modal-btn-primary { background-color: var(--accent-color); border-color: var(--accent-color); }
        .modal-btn-danger { background-color: var(--accent-red); border-color: var(--accent-red); }
        .modal-btn-secondary { background-color: #555; border-color: #666; }

    </style>
</head>
<body>
    <header><h1>UNOC - Unified NOC UI</h1></header>

    <div id="hud">
        <div class="hud-item"><h3>Ger√§te Online</h3><p id="hud-devices">...</p></div>
        <div class="hud-item"><h3>Links Up</h3><p id="hud-links">...</p></div>
        <div class="hud-item"><h3>Alarme</h3><p id="hud-alarms">...</p></div>
    </div>

    <main>
        <aside id="left-sidebar">
            <div id="cli-panel">
                <h2>Command Line</h2>
                <div id="cli-interaction-area">
                    <div id="cli-suggestions"></div>
                    <div id="cli-input-wrapper">
                        <span id="cli-prompt">UNOC></span>
                        <input type="text" id="cli-input" placeholder="Befehl eingeben (z.B. 'help')...">
                    </div>
                </div>
                <div id="cli-output"></div>
            </div>
        </aside>

        <div id="center-column">
             <div id="view-container">
                <div id="network-container"></div>
                <div id="map-container"></div>
                <div id="view-toggle">
                    <button type="button" id="toggle-btn">Kartenansicht</button>
                </div>
            </div>
            <div id="event-log-panel" class="panel">
                <h2>Event Log</h2>
                <ul id="event-log"><li class="loader">Lade Events...</li></ul>
            </div>
        </div>

        <aside id="right-sidebar">
            <div id="properties-panel" class="panel">
                <h2>Eigenschaften</h2>
                <div id="properties-content" class="loader">Kein Element ausgew√§hlt</div>
            </div>
            <div id="ring-panel" class="panel">
                <h2>Ring Status</h2>
                <div id="ring-info" class="loader">Lade Ring-Status...</div>
            </div>
            <div id="controls-panel" class="panel">
                <h2>Steuerung</h2>
                <div class="button-group">
                    <button type="button" id="undo-btn" disabled>Undo</button>
                    <button type="button" id="redo-btn" disabled>Redo</button>
                    <button type="button" id="reset-highlight-btn" style="background-color: #555;">Reset Highlight</button>
                </div>
            </div>
            <div id="scenario-panel" class="panel">
                <h2>Szenarien</h2>
                <select id="splitter-select" aria-label="Splitter for fiber cut scenario"></select>
                <button type="button" id="fiber-cut-btn">Faserschnitt simulieren</button>
            </div>
            <div id="snapshot-panel" class="panel">
                <h2>Snapshots</h2>
                <div class="input-group">
                    <input type="text" id="snapshot-name" placeholder="Snapshot-Name...">
                    <button type="button" id="save-snapshot-btn">Speichern</button>
                    <button type="button" id="load-snapshot-btn">Laden</button>
                </div>
            </div>
        </aside>
    </main>
    
    <div id="modal-overlay" class="hidden">
        <div id="modal-box">
            <h2 id="modal-title"></h2>
            <p id="modal-message"></p>
            <div id="modal-buttons"></div>
        </div>
    </div>

    <script>
        const backendUrl = "http://127.0.0.1:5000";
        let network = null, map = null, nodes = new vis.DataSet([]), edges = new vis.DataSet([]);
        let mapMarkers = {}, mapLines = {}, currentView = 'topo', eventPollInterval = null;
        let highlightedPath = { nodes: [], links: [] };

        const statusToColor = {
            online: { border: "#4CAF50", background: "#2e7d32" }, offline: { border: "#F44336", background: "#c62828" },
            maintenance: { border: "#FFC107", background: "#ffa000" }, up: { color: "#4CAF50", highlight: "#66BB6A" },
            down: { color: "#F44336", highlight: "#EF5350" }, degraded: { color: "#FFC107", highlight: "#FFCA28" },
            blocking: { color: "#FFC107", highlight: "#FFCA28" }
        };
        const getEdgeLeafletColor = (status) => (statusToColor[status] || { color: '#9E9E9E' }).color;

        const formatDeviceToNode = d => ({id: d.id, label: `${d.type}\n(${d.id})`, shape: 'box', borderWidth: 1, color: statusToColor[d.status], font: { color: '#ffffff' }, data: d});
        const formatLinkToEdge = l => ({id: l.id, from: l.source, to: l.target, width: 1, color: (statusToColor[l.status] || {}).color, arrows: 'to, from', dashes: l.status === 'blocking' ? [5, 5] : false, data: l, label: l.id, font: { color: '#aaa', size: 11, align: 'top', strokeWidth: 3, strokeColor: '#1a1a1a' }});

        async function initialize() {
            try {
                const response = await fetch(`${backendUrl}/api/topology`);
                if (!response.ok) throw new Error(`Backend nicht erreichbar: ${response.statusText}`);
                const topology = await response.json();
                
                const splitterSelect = document.getElementById('splitter-select');
                splitterSelect.innerHTML = '';
                topology.devices.filter(d => d.type.toLowerCase() === 'splitter').forEach(d => {
                    const option = document.createElement('option');
                    option.value = d.id;
                    option.textContent = d.id;
                    splitterSelect.appendChild(option);
                });

                if (!network) {
                    const container = document.getElementById('network-container');
                    network = new vis.Network(container, { nodes, edges }, { interaction: { hover: true } });
                }
                 if (!map) {
                    map = L.map('map-container').setView([51.96, 7.62], 10);
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                        attribution: '&copy; OpenStreetMap &copy; CARTO', maxZoom: 20
                    }).addTo(map);
                }

                refreshTopologyDisplay(topology);
                
                if (!eventPollInterval) {
                    setupEventListeners();
                    pollForUpdates();
                    eventPollInterval = setInterval(pollForUpdates, 2500);
                }
            } catch (e) { 
                console.error("Fehler bei der Initialisierung:", e);
                const container = document.getElementById('network-container');
                container.innerHTML = `<p style="color: var(--accent-red); padding: 20px;">Verbindung zum Backend fehlgeschlagen. L√§uft der Server auf ${backendUrl}?</p>`;
            }
        }
        
        async function pollForUpdates() {
            try {
                const [eventsRes, historyRes, statsRes, topoRes] = await Promise.all([
                    fetch(`${backendUrl}/api/events`), fetch(`${backendUrl}/api/history/status`),
                    fetch(`${backendUrl}/api/topology/stats`), fetch(`${backendUrl}/api/topology`)
                ]);
                
                if (!eventsRes.ok || !historyRes.ok || !statsRes.ok || !topoRes.ok) throw new Error("Backend nicht erreichbar");

                const events = await eventsRes.json();
                const historyStatus = await historyRes.json();
                const stats = await statsRes.json();
                const topology = await topoRes.json();
                
                document.getElementById('event-log').innerHTML = events.map(e => `<li>${e}</li>`).join('');
                updateHud(stats);
                updateHistoryButtons(historyStatus);

                if (highlightedPath.nodes.length === 0) {
                    nodes.update(topology.devices.map(formatDeviceToNode));
                    edges.update(topology.links.map(formatLinkToEdge));
                }
                updateRingPanel(topology);
                syncMapWithState(topology);
            } catch (error) { console.error("Polling-Fehler:", error); }
        }

        function refreshTopologyDisplay(topologyData) {
            nodes.clear();
            edges.clear();
            nodes.add(topologyData.devices.map(formatDeviceToNode));
            edges.add(topologyData.links.map(formatLinkToEdge));
            updateRingPanel(topologyData);
            initializeMapView(topologyData); 
        }

        function initializeMapView(topology) {
            if(map){
                Object.values(mapMarkers).forEach(marker => marker.remove());
                Object.values(mapLines).forEach(line => line.remove());
                mapMarkers = {}; mapLines = {};
            }
            topology.devices.forEach(device => { if (device.coordinates) mapMarkers[device.id] = L.marker(device.coordinates).addTo(map).bindPopup(`<b>${device.id}</b><br>${device.type}`); });
            topology.links.forEach(link => {
                const source = topology.devices.find(d => d.id === link.source);
                const target = topology.devices.find(d => d.id === link.target);
                if (source?.coordinates && target?.coordinates) {
                    mapLines[link.id] = L.polyline([source.coordinates, target.coordinates], { color: getEdgeLeafletColor(link.status), weight: 3, dashArray: link.status === 'blocking' ? '5, 5' : null }).addTo(map);
                }
            });
        }
        
        function syncMapWithState(topology) {
            if (!map) return;
            topology.links.forEach(link => {
                if (mapLines[link.id]) {
                    mapLines[link.id].setStyle({ color: getEdgeLeafletColor(link.status), dashArray: link.status === 'blocking' ? '5, 5' : null });
                }
            });
        }
        
        function updateHud(stats) {
            document.getElementById('hud-devices').textContent = `${stats.devices_online} / ${stats.devices_total}`;
            document.getElementById('hud-links').textContent = `${stats.links_up} / ${stats.links_total}`;
            const alarmsEl = document.getElementById('hud-alarms');
            alarmsEl.textContent = stats.alarms;
            alarmsEl.style.color = stats.alarms > 0 ? 'var(--accent-red)' : 'var(--accent-green)';
        }
        
        function updateHistoryButtons(status) {
            document.getElementById('undo-btn').disabled = !status.can_undo;
            document.getElementById('redo-btn').disabled = !status.can_redo;
        }

        function updateRingPanel(topology) {
            const ringInfoDiv = document.getElementById('ring-info');
            if (!topology.rings?.length) { ringInfoDiv.innerHTML = '<span class="loader">Keine Ringe definiert.</span>'; return; }
            let html = '<table>';
            topology.rings.forEach(ring => {
                const rpl = topology.links.find(l => l.id === ring.rpl_link_id);
                if (rpl) {
                    const statusClass = rpl.status === 'blocking' ? 'status-blocking' : 'status-forwarding';
                    html += `<tr><td><b>${ring.name}</b></td><td class="${statusClass}">${rpl.status.toUpperCase()}</td></tr>`;
                }
            });
            ringInfoDiv.innerHTML = html + '</table>';
        }

        async function renderProperties(dataToShow) {
            const contentDiv = document.getElementById('properties-content');
            if (!dataToShow) { contentDiv.innerHTML = '<span class="loader">Kein Element ausgew√§hlt</span>'; return; }
            let table = '<table>';
            for (const [k, v] of Object.entries(dataToShow)) {
                if (k === 'properties') continue;
                let displayValue = v;
                if (k === 'coordinates' && Array.isArray(v)) displayValue = `${v[0].toFixed(4)}, ${v[1].toFixed(4)}`;
                else if (typeof v === 'object' && v !== null) displayValue = JSON.stringify(v);
                table += `<tr><th style="text-transform: capitalize;">${k}</th><td>${displayValue}</td></tr>`;
            }
            if (dataToShow.properties && Object.keys(dataToShow.properties).length > 0) {
                table += `<tr><th colspan="2" style="text-align:center; background-color: #333;">Properties</th></tr>`;
                for (const [propKey, propValue] of Object.entries(dataToShow.properties)) {
                     table += `<tr><th style="padding-left: 20px;">${propKey}</th><td>${propValue}</td></tr>`;
                }
            }
            table += '</table>';
            contentDiv.innerHTML = table;
            if (dataToShow.type === 'ONT') {
                try {
                    const response = await fetch(`${backendUrl}/api/devices/${dataToShow.id}/signal`);
                    if (!response.ok) return;
                    const signalInfo = await response.json();
                    if (!signalInfo || signalInfo.status === 'NOT_APPLICABLE') return;
                    const signalRow = document.createElement('tr');
                    let signalCellHTML = '';
                    if (signalInfo.status === 'NO_PATH') {
                        signalCellHTML = `<td class="signal-los" colspan="2">${signalInfo.status} (Pfad unterbrochen)</td>`;
                    } else if (signalInfo.power_dbm !== null) {
                        const signalStatusClass = `signal-${signalInfo.status.toLowerCase()}`;
                        signalCellHTML = `<td class="${signalStatusClass}" colspan="2">${signalInfo.power_dbm} dBm (${signalInfo.status})</td>`;
                    }
                    if (signalCellHTML) {
                        const tableElement = contentDiv.querySelector('table');
                        if (tableElement) tableElement.innerHTML += `<tr><th style="text-align:center;" colspan="2">Signal Level</th></tr><tr>${signalCellHTML}</tr>`;
                    }
                } catch (e) { console.error("Fehler beim Abrufen des Signalpegels:", e); }
            }
        }
        
        function toggleView() {
            const mapContainer = document.getElementById('map-container');
            const toggleBtn = document.getElementById('toggle-btn');
            const isTopo = currentView === 'topo';
            mapContainer.style.visibility = isTopo ? 'visible' : 'hidden';
            toggleBtn.textContent = isTopo ? 'Topologieansicht' : 'Kartenansicht';
            currentView = isTopo ? 'map' : 'topo';
            if (isTopo) map.invalidateSize();
        }

        function showModal(title, message, buttons = [{ text: 'OK', class: 'modal-btn-primary', callback: hideModal }]) {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-message').innerHTML = message;
            const buttonContainer = document.getElementById('modal-buttons');
            buttonContainer.innerHTML = '';
            buttons.forEach(btnInfo => {
                const button = document.createElement('button');
                button.textContent = btnInfo.text;
                button.className = btnInfo.class || 'modal-btn-secondary';
                button.onclick = () => { hideModal(); if (btnInfo.callback) btnInfo.callback(); };
                buttonContainer.appendChild(button);
            });
            document.getElementById('modal-overlay').classList.remove('hidden');
        }

        function hideModal() { document.getElementById('modal-overlay').classList.add('hidden'); }

        function setupEventListeners() {
            network.on('click', params => {
                if (params.nodes.length === 0 && params.edges.length === 0) {
                    setTimeout(() => resetHighlight(), 0);
                }
                const elementId = params.nodes[0] || params.edges[0];
                const dataset = params.nodes.length ? nodes : edges;
                renderProperties(elementId ? dataset.get(elementId).data : null);
            });
            document.getElementById('toggle-btn').addEventListener('click', toggleView);
            document.getElementById('undo-btn').addEventListener('click', () => postAction('/api/simulation/undo'));
            document.getElementById('redo-btn').addEventListener('click', () => postAction('/api/simulation/redo'));
            document.getElementById('reset-highlight-btn').addEventListener('click', resetHighlight);
            document.getElementById('fiber-cut-btn').addEventListener('click', simulateFiberCut);
            document.getElementById('save-snapshot-btn').addEventListener('click', saveSnapshot);
            document.getElementById('load-snapshot-btn').addEventListener('click', loadSnapshot);
            document.getElementById('cli-input').addEventListener('keydown', handleCliKeyDown);
            document.getElementById('cli-input').addEventListener('keyup', debounce(handleAutocomplete, 250));
            document.addEventListener('click', (e) => {
                if (document.getElementById('cli-suggestions') && !document.getElementById('cli-interaction-area').contains(e.target)) {
                    clearSuggestions();
                }
            });
        }

        async function postAction(endpoint, payload = {}) {
            try {
                const res = await fetch(`${backendUrl}${endpoint}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!res.ok) { const errorData = await res.json(); throw new Error(errorData.description || "Unbekannter Backend-Fehler"); }
                if (endpoint.includes('load')) { await initialize(); } 
                else { await pollForUpdates(); }
            } catch (error) {
                console.error("Aktion fehlgeschlagen:", error);
                showModal('Aktion fehlgeschlagen', error.message);
            }
        }

        function simulateFiberCut() {
            const nodeId = document.getElementById('splitter-select').value;
            if (nodeId) showModal('Faserschnitt simulieren', `Soll ein Faserschnitt bei <strong>${nodeId}</strong> wirklich simuliert werden?`, [{ text: 'Abbrechen', class: 'modal-btn-secondary' }, { text: 'Simulieren', class: 'modal-btn-danger', callback: () => postAction('/api/simulation/fiber-cut', { node_id: nodeId }) }]);
        }
        function saveSnapshot() {
            const name = document.getElementById('snapshot-name').value.trim();
            if (name) postAction('/api/snapshot/save', { name });
            else showModal('Fehler', 'Bitte einen Namen f√ºr den Snapshot eingeben.');
        }
        function loadSnapshot() {
            const name = document.getElementById('snapshot-name').value.trim();
            if (name) showModal('Snapshot laden', `Soll der Snapshot '<strong>${name}</strong>' wirklich geladen werden?`, [{ text: 'Abbrechen', class: 'modal-btn-secondary' }, { text: 'Laden', class: 'modal-btn-primary', callback: () => postAction('/api/snapshot/load', { name }) }]);
            else showModal('Fehler', 'Bitte den Namen des zu ladenden Snapshots eingeben.');
        }

        const KNOWN_COMMANDS = ['help', 'undo', 'redo', 'cut', 'fiber-cut', 'link-down', 'link-up', 'link-degraded', 'trace'];
        function debounce(func, delay) { let timeout; return function(...args) { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), delay); }; }
        function showCliOutput(message, type = 'info') {
            const cliOutput = document.getElementById('cli-output');
            if(!cliOutput) return;
            const colorMap = { error: 'var(--accent-red)', warning: '#FFC107', info: 'var(--text-color)' };
            cliOutput.innerHTML += `<div>${message}</div>`;
            cliOutput.querySelector('div:last-child').style.color = colorMap[type] || colorMap.info;
            cliOutput.scrollTop = cliOutput.scrollHeight;
        }

        async function handleCliCommand(inputElement) {
            const commandStr = inputElement.value.trim();
            if (!commandStr) return;
            showCliOutput(`<span style="color: var(--text-muted);">UNOC></span> ${commandStr}`);
            const [command, ...args] = commandStr.split(' ');
            inputElement.value = ''; clearSuggestions();
            if (command === 'trace') { await tracePath(args[0], args[1]); return; }
            if (command === "help") { showCliOutput(`Verf√ºgbare Befehle: ${KNOWN_COMMANDS.join(', ')}`, 'info'); }
            else if (command === "undo") { await postAction('/api/simulation/undo'); }
            else if (command === "redo") { await postAction('/api/simulation/redo'); }
            else if (command === "cut" || command === "fiber-cut") { await postAction('/api/simulation/fiber-cut', { node_id: args[0] }); }
            else if (["link-down", "link-up", "link-degraded"].includes(command)) { await postAction(`/api/links/${args[0]}/status`, { status: command.split("-")[1] }); }
            else { showCliOutput(`Unbekannter Befehl: '${command}'.`, 'error'); }
        }

        async function tracePath(startNode, endNode) {
            resetHighlight();
            if (!startNode || !endNode) { showCliOutput("Fehler: `trace` ben√∂tigt Start- und Endknoten. Bsp: trace NODE-A NODE-B", 'error'); return; }
            try {
                const response = await fetch(`${backendUrl}/api/simulation/trace-path`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ start_node: startNode, end_node: endNode }) });
                if (!response.ok) { const error = await response.json(); throw new Error(error.description || "Unbekannter Fehler bei der Pfadsuche"); }
                const path = await response.json();
                if (path.nodes.length === 0) { showCliOutput(`Kein aktiver Pfad zwischen ${startNode} und ${endNode} gefunden.`, 'warning'); }
                else {
                    highlightedPath = { nodes: path.nodes, links: path.links };
                    nodes.update(path.nodes.map(id => ({ id, borderWidth: 3, color: { border: '#00BFFF' } })));
                    edges.update(path.links.map(id => ({ id, width: 4, color: '#00BFFF' })));
                    showCliOutput(`Pfad gefunden: ${path.nodes.join(' -> ')}`);
                }
            } catch (e) { showCliOutput(`Fehler bei der Pfadverfolgung: ${e.message}`, 'error'); }
        }
        
        function resetHighlight() {
            if (highlightedPath.nodes.length === 0 && highlightedPath.links.length === 0) return;
            const nodesToUpdate = nodes.get(highlightedPath.nodes);
            const edgesToUpdate = edges.get(highlightedPath.links);
            if (nodesToUpdate.length > 0) {
                const nodeResets = nodesToUpdate.map(node => { const defaultStyle = formatDeviceToNode(node.data); return { id: node.id, borderWidth: defaultStyle.borderWidth, color: defaultStyle.color }; });
                nodes.update(nodeResets);
            }
            if (edgesToUpdate.length > 0) {
                const edgeResets = edgesToUpdate.map(edge => { const defaultStyle = formatLinkToEdge(edge.data); return { id: edge.id, width: defaultStyle.width, color: defaultStyle.color }; });
                edges.update(edgeResets);
            }
            highlightedPath = { nodes: [], links: [] };
        }

        function handleCliKeyDown(event) {
            const suggestions = document.querySelectorAll('.suggestion-item');
            let activeIndex = -1;
            suggestions.forEach((s, i) => { if (s.classList.contains('active')) activeIndex = i; });
            if (event.key === 'Enter') {
                event.preventDefault();
                if (activeIndex > -1) { suggestions[activeIndex].click(); }
                else { handleCliCommand(event.target); }
            } else if (event.key === 'ArrowDown') {
                event.preventDefault();
                if (activeIndex < suggestions.length - 1) { if (activeIndex > -1) suggestions[activeIndex].classList.remove('active'); suggestions[activeIndex + 1].classList.add('active'); }
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                if (activeIndex > 0) { suggestions[activeIndex].classList.remove('active'); suggestions[activeIndex - 1].classList.add('active'); }
            } else if (event.key === 'Escape') { clearSuggestions(); }
        }

        function handleAutocomplete(event) {
            const text = event.target.value;
            const parts = text.split(' ');
            const command = parts[0];
            const currentPartIndex = parts.length - 1;
            const partial = parts[currentPartIndex];
            if (currentPartIndex === 0) {
                const suggestions = KNOWN_COMMANDS.filter(c => c.startsWith(partial));
                renderSuggestions(suggestions, "");
                return;
            }
            const baseCommand = parts.slice(0, currentPartIndex).join(' ');
            let suggestions = [];
            const commandsWithNodeIds = ['cut', 'fiber-cut', 'trace'];
            const commandsWithLinkIds = ['link-down', 'link-up', 'link-degraded'];
            if (commandsWithLinkIds.includes(command)) {
                if (currentPartIndex === 1) { suggestions = edges.get({ filter: item => item.id.toLowerCase().startsWith(partial.toLowerCase()) }).map(item => item.id); }
            } else if (commandsWithNodeIds.includes(command)) {
                if (currentPartIndex === 1 || (command === 'trace' && currentPartIndex === 2)) {
                    const existingNodes = parts.slice(1, currentPartIndex);
                    suggestions = nodes.get({ filter: item => !existingNodes.includes(item.id) && item.id.toLowerCase().startsWith(partial.toLowerCase()) }).map(item => item.id);
                }
            }
            renderSuggestions(suggestions, baseCommand);
        }
        
        function renderSuggestions(suggestions, baseCommand) {
            const container = document.getElementById('cli-suggestions');
            if (suggestions.length === 0) { clearSuggestions(); return; }
            container.innerHTML = suggestions.map(s => `<div class="suggestion-item" onclick="selectSuggestion('${baseCommand}', '${s}')">${s}</div>`).join('');
        }

        function selectSuggestion(baseCommand, id) {
            const inputElement = document.getElementById('cli-input');
            inputElement.value = (baseCommand ? `${baseCommand} ` : '') + `${id} `;
            inputElement.focus();
            inputElement.dispatchEvent(new Event('keyup', { bubbles: true }));
        }

        function clearSuggestions() {
            const container = document.getElementById('cli-suggestions');
            if(container) container.innerHTML = '';
        }

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>