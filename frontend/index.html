<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>UNOC - Unified NOC UI</title>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <!-- NEU: Leaflet.js für die Karte -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --header-bg: #2a2a2a;
            --panel-bg: #242424;
            --border-color: #444;
            --text-color: #e0e0e0;
            --text-muted: #aaa;
            --accent-color: #4CAF50;
            --accent-red: #F44336;
            --accent-green: #4CAF50;
        }

        body, html {
            margin: 0; padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color); color: var(--text-color);
            height: 100vh; overflow: hidden; display: flex; flex-direction: column;
        }

        header {
            background-color: var(--header-bg);
            padding: 10px 20px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        main {
            display: flex;
            flex-grow: 1;
            height: calc(100% - 100px); /* Höhe an HUD anpassen */
        }

        h1, h2 {
            margin: 0; padding: 0; font-weight: 500;
        }
        
        /* Container für die umschaltbaren Ansichten */
        #view-container {
            width: 75%;
            height: 100%;
            position: relative;
            border-right: 1px solid var(--border-color);
        }

        #network-container, #map-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #map-container {
            z-index: 10;
            visibility: hidden; /* Standardmäßig unsichtbar */
            background-color: var(--bg-color);
        }
        
        #view-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 20;
        }
        
        #view-toggle button {
            width: auto;
            padding: 8px 12px;
            background-color: rgba(42, 42, 42, 0.8);
        }

        #sidebar {
            width: 25%; height: 100%;
            display: flex; flex-direction: column;
            background-color: var(--panel-bg);
        }

        .panel {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            overflow-y: auto;
        }

        .panel h2 {
            margin-bottom: 10px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        #scenario-panel, #snapshot-panel, #controls-panel, #cli-panel, #ring-panel {
            flex-shrink: 0;
        }

        #properties-panel {
            flex-grow: 1;
        }

        #events-panel {
            height: 35%; flex-shrink: 0;
        }

        #event-log {
            list-style: none; padding: 0; margin: 0;
            font-family: monospace; font-size: 12px;
        }

        #event-log li {
            padding: 4px 0; border-bottom: 1px solid #333;
        }

        #event-log li:first-child {
            color: var(--accent-color);
        }

        .loader {
            color: var(--text-muted); font-style: italic;
        }

        input, button, select {
            width: calc(100% - 10px);
            padding: 8px 5px;
            margin-bottom: 10px;
            border-radius: 3px;
            border: 1px solid #666;
            background-color: #333;
            color: var(--text-color);
            font-size: 14px;
        }

        button {
            cursor: pointer;
            background-color: #007BFF;
            border-color: #007BFF;
            font-weight: bold;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #555;
            border-color: #666;
            cursor: not-allowed;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        #hud {
            display: flex;
            justify-content: space-around;
            background-color: #2c2c2c;
            padding: 10px;
            border-bottom: 1px solid #444;
            flex-shrink: 0;
        }

        .hud-item { text-align: center; }
        .hud-item h3 { margin: 0; font-size: 14px; color: #aaa; }
        .hud-item p { margin: 0; font-size: 20px; font-weight: bold; }

        #properties-content table { width: 100%; border-collapse: collapse; font-size: 13px; }
        #properties-content th, #properties-content td { padding: 4px 8px; text-align: left; border-bottom: 1px solid #333; }

        #cli-panel { padding: 10px; border-top: 1px solid #444; }
        #cli-input { width: calc(100% - 20px); background-color: #111; border: 1px solid #555; color: #00ff00; font-family: monospace; padding: 8px; }
        
        #ring-panel table { width: 100%; text-align: left; border-collapse: collapse; }
        #ring-panel td { padding: 4px 2px; }
        #ring-panel .status-blocking { color: #FFC107; font-weight: bold; }
        #ring-panel .status-forwarding { color: var(--accent-green); font-weight: bold; }
    </style>
</head>
<body>
    <header><h1>UNOC - Netzwerk Visualisierung</h1></header>

    <div id="hud">
        <div class="hud-item"><h3>Geräte Online</h3><p id="hud-devices">...</p></div>
        <div class="hud-item"><h3>Links Up</h3><p id="hud-links">...</p></div>
        <div class="hud-item"><h3>Alarme</h3><p id="hud-alarms">...</p></div>
    </div>

    <main>
        <div id="view-container">
            <div id="network-container"></div>
            <div id="map-container"></div>
            <div id="view-toggle">
                <button id="toggle-btn">Kartenansicht</button>
            </div>
        </div>
        <aside id="sidebar">
            <div id="ring-panel" class="panel">
                <h2>Ring Status</h2>
                <div id="ring-info" class="loader">Lade Ring-Status...</div>
            </div>
            
            <div id="properties-panel" class="panel">
                <h2>Eigenschaften</h2>
                <div id="properties-content" class="loader">Kein Element ausgewählt</div>
            </div>

            <div id="controls-panel" class="panel">
                <h2>Steuerung</h2>
                <div class="button-group">
                    <button id="undo-btn" disabled>Undo</button>
                    <button id="redo-btn" disabled>Redo</button>
                </div>
            </div>

            <div id="scenario-panel" class="panel">
                <h2>Szenarien</h2>
                <select id="splitter-select"></select>
                <button id="fiber-cut-btn">Faserschnitt simulieren</button>
            </div>

            <div id="snapshot-panel" class="panel">
                <h2>Snapshots</h2>
                <input type="text" id="snapshot-name" placeholder="Snapshot-Name eingeben...">
                <div class="button-group">
                    <button id="save-snapshot-btn">Speichern</button>
                    <button id="load-snapshot-btn">Laden</button>
                </div>
            </div>

            <div id="events-panel" class="panel">
                <h2>Event Log</h2>
                <ul id="event-log"><li class="loader">Lade Events...</li></ul>
            </div>

            <div id="cli-panel">
                <input type="text" id="cli-input" placeholder="[CLI]> z.B. link-down link-01">
            </div>
        </aside>
    </main>

    <script>
        // --- Globale Variablen ---
        const backendUrl = "http://127.0.0.1:5000";
        let network = null; // vis-network Instanz
        let map = null;     // Leaflet Karteninstanz
        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        let mapMarkers = {}; // Speichert Leaflet Marker
        let mapLines = {};   // Speichert Leaflet Linien
        let currentView = 'topo'; // 'topo' oder 'map'
        let eventPollInterval = null;

        // --- Visuelle Stile ---
        const statusToColor = {
            online: { border: "#4CAF50", background: "#2e7d32" },
            offline: { border: "#F44336", background: "#c62828" },
            maintenance: { border: "#FFC107", background: "#ffa000" },
            up: { color: "#4CAF50", highlight: "#66BB6A" },
            down: { color: "#F44336", highlight: "#EF5350" },
            degraded: { color: "#FFC107", highlight: "#FFCA28" },
            blocking: { color: "#FFC107", highlight: "#FFCA28" }
        };

        const getEdgeLeafletColor = (status) => {
            const style = statusToColor[status] || { color: '#9E9E9E' };
            return style.color;
        };

        // --- Formatierungsfunktionen ---
        function formatDeviceToNode(d) {
            return {
                id: d.id, label: `${d.type}\n(${d.id})`, shape: 'box',
                color: statusToColor[d.status], font: { color: '#ffffff' }, data: d
            };
        }

        function formatLinkToEdge(l) {
            const edge = {
                id: l.id, from: l.source, to: l.target,
                color: statusToColor[l.status], arrows: 'to, from', data: l
            };
            if (l.status === 'blocking') edge.dashes = [5, 5];
            return edge;
        }
        
        // --- Initialisierungsfunktionen ---
        async function initialize() {
            try {
                const response = await fetch(`${backendUrl}/api/topology`);
                const topology = await response.json();

                // Topologie-Ansicht
                nodes.clear(); edges.clear();
                nodes.add(topology.devices.map(formatDeviceToNode));
                edges.add(topology.links.map(formatLinkToEdge));

                if (!network) {
                    const container = document.getElementById('network-container');
                    network = new vis.Network(container, { nodes, edges }, {});
                }
                
                // Karten-Ansicht
                initializeMap(topology);

                // UI-Elemente
                populateSplitterDropdown(topology.devices);
                updateRingPanel(topology);

                // Event Listeners und Polling
                if (!eventPollInterval) {
                    setupEventListeners();
                    eventPollInterval = setInterval(pollForUpdates, 2000);
                }
            } catch (e) {
                console.error("Fehler bei der Initialisierung:", e);
            }
        }

        function initializeMap(topology) {
            if (map) return; // Nur einmal initialisieren
            map = L.map('map-container').setView([52.0, 7.5], 9); // Zentriert auf das Münsterland
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 20
            }).addTo(map);

            // Marker und Linien zeichnen
            topology.devices.forEach(device => {
                if (device.coordinates) {
                    const marker = L.marker(device.coordinates).addTo(map)
                        .bindPopup(`<b>${device.id}</b><br>${device.type}`);
                    mapMarkers[device.id] = marker;
                }
            });
            topology.links.forEach(link => {
                const source = topology.devices.find(d => d.id === link.source);
                const target = topology.devices.find(d => d.id === link.target);
                if (source && target && source.coordinates && target.coordinates) {
                    const latlngs = [source.coordinates, target.coordinates];
                    const polyline = L.polyline(latlngs, { 
                        color: getEdgeLeafletColor(link.status),
                        weight: 3,
                        dashArray: link.status === 'blocking' ? '5, 5' : null
                    }).addTo(map);
                    mapLines[link.id] = polyline;
                }
            });
        }

        // --- Update- und Synchronisationsfunktionen ---
        async function pollForUpdates() {
            try {
                const [eventsRes, historyRes, statsRes] = await Promise.all([
                    fetch(`${backendUrl}/api/events`),
                    fetch(`${backendUrl}/api/history/status`),
                    fetch(`${backendUrl}/api/topology/stats`)
                ]);
                
                const events = await eventsRes.json();
                const historyStatus = await historyRes.json();
                const stats = await statsRes.json();

                const eventLog = document.getElementById('event-log');
                if (events[0] !== eventLog.children[0]?.textContent) {
                    eventLog.innerHTML = events.map(e => `<li>${e}</li>`).join('');
                    await refreshTopologyDisplay();
                }

                updateHud(stats);
                updateHistoryButtons(historyStatus);
            } catch (error) { console.error("Polling-Fehler:", error); }
        }

        async function refreshTopologyDisplay() {
            try {
                const res = await fetch(`${backendUrl}/api/topology`);
                if (!res.ok) return;
                const topology = await res.json();
                
                // Topologie-Ansicht updaten
                nodes.update(topology.devices.map(formatDeviceToNode));
                edges.update(topology.links.map(formatLinkToEdge));
                
                // UI-Panels updaten
                updateRingPanel(topology);
                
                // Karten-Ansicht synchronisieren
                syncMapWithState(topology);
            } catch (error) { console.error("Fehler bei Topologie-Aktualisierung:", error); }
        }

        function syncMapWithState(topology) {
            if (!map) return;
            topology.links.forEach(link => {
                if (mapLines[link.id]) {
                    mapLines[link.id].setStyle({
                        color: getEdgeLeafletColor(link.status),
                        dashArray: link.status === 'blocking' ? '5, 5' : null
                    });
                }
            });
            // Zukünftig: Marker-Status auch anpassen
        }

        // --- UI-Steuerung und Hilfsfunktionen ---
        function updateRingPanel(topology) {
            const ringInfoDiv = document.getElementById('ring-info');
            if (!topology.rings || topology.rings.length === 0) {
                ringInfoDiv.innerHTML = '<span class="loader">Keine Ringe definiert.</span>';
                return;
            }
            let html = '<table>';
            topology.rings.forEach(ring => {
                const rpl = topology.links.find(l => l.id === ring.rpl_link_id);
                if (rpl) {
                    const statusClass = rpl.status === 'blocking' ? 'status-blocking' : 'status-forwarding';
                    html += `<tr><td><b>${ring.name}</b></td><td class="${statusClass}">${rpl.status.toUpperCase()}</td></tr>`;
                }
            });
            html += '</table>';
            ringInfoDiv.innerHTML = html;
        }

        function updateHud(stats) {
            document.getElementById('hud-devices').textContent = `${stats.devices_online} / ${stats.devices_total}`;
            document.getElementById('hud-links').textContent = `${stats.links_up} / ${stats.links_total}`;
            const alarms = document.getElementById('hud-alarms');
            alarms.textContent = stats.alarms;
            alarms.style.color = stats.alarms > 0 ? 'var(--accent-red)' : 'var(--accent-green)';
        }

        function updateHistoryButtons(status) {
            document.getElementById('undo-btn').disabled = !status.can_undo;
            document.getElementById('redo-btn').disabled = !status.can_redo;
        }

        function populateSplitterDropdown(devices) {
            const select = document.getElementById('splitter-select');
            select.innerHTML = '';
            devices.filter(d => d.type.toLowerCase() === 'splitter')
                   .forEach(d => {
                       const option = document.createElement('option');
                       option.value = d.id;
                       option.textContent = d.id;
                       select.appendChild(option);
                   });
        }

        function renderProperties(data) {
            const content = document.getElementById('properties-content');
            if (!data) return content.innerHTML = '<span class="loader">Kein Element ausgewählt</span>';
            let table = '<table>';
            for (const [k, v] of Object.entries(data)) {
                let displayValue = v;
                if (k === 'coordinates' && Array.isArray(v)) {
                    displayValue = `${v[0].toFixed(4)}, ${v[1].toFixed(4)}`;
                } else if (typeof v === 'object' && v !== null) {
                    displayValue = JSON.stringify(v);
                }
                table += `<tr><th>${k}</th><td>${displayValue}</td></tr>`;
            }
            table += '</table>';
            content.innerHTML = table;
        }
        
        function toggleView() {
            const mapContainer = document.getElementById('map-container');
            const toggleBtn = document.getElementById('toggle-btn');
            if (currentView === 'topo') {
                mapContainer.style.visibility = 'visible';
                toggleBtn.textContent = 'Topologieansicht';
                currentView = 'map';
                // Wichtig, damit die Karte korrekt gezeichnet wird, wenn sie sichtbar wird
                map.invalidateSize(); 
            } else {
                mapContainer.style.visibility = 'hidden';
                toggleBtn.textContent = 'Kartenansicht';
                currentView = 'topo';
            }
        }

        // --- Event Listeners ---
        function setupEventListeners() {
            network.on('click', (params) => {
                const data = params.nodes.length ? nodes.get(params.nodes[0]).data :
                             params.edges.length ? edges.get(params.edges[0]).data : null;
                renderProperties(data);
            });

            document.getElementById('undo-btn').onclick = () => postAction('/api/simulation/undo');
            document.getElementById('redo-btn').onclick = () => postAction('/api/simulation/redo');
            document.getElementById('fiber-cut-btn').onclick = simulateFiberCut;
            document.getElementById('save-snapshot-btn').onclick = saveSnapshot;
            document.getElementById('load-snapshot-btn').onclick = loadSnapshot;
            document.getElementById('cli-input').addEventListener('keydown', handleCliCommand);
            document.getElementById('toggle-btn').addEventListener('click', toggleView);
        }

        async function postAction(endpoint, payload = {}) {
            try {
                const res = await fetch(`${backendUrl}${endpoint}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.description || "Unbekannter Backend-Fehler");
                }
                await pollForUpdates();
            } catch (error) {
                console.error("Aktion fehlgeschlagen:", error);
                alert(`Fehler: ${error.message}`);
            }
        }

        async function simulateFiberCut() {
            const nodeId = document.getElementById('splitter-select').value;
            if (!nodeId) return alert("Bitte einen Splitter auswählen.");
            if (confirm(`Soll ein Faserschnitt bei ${nodeId} simuliert werden?`)) {
                await postAction('/api/simulation/fiber-cut', { node_id: nodeId });
            }
        }

        async function saveSnapshot() {
            const name = document.getElementById('snapshot-name').value.trim();
            if (!name) return alert("Bitte einen Namen für den Snapshot eingeben.");
            await postAction('/api/snapshot/save', { name });
        }

        async function loadSnapshot() {
            const name = document.getElementById('snapshot-name').value.trim();
            if (!name) return alert("Bitte den Namen des zu ladenden Snapshots eingeben.");
            if (confirm(`Soll der Snapshot '${name}' wirklich geladen werden? Alle ungespeicherten Änderungen gehen verloren.`)) {
                await postAction('/api/snapshot/load', { name });
            }
        }

        async function handleCliCommand(event) {
            if (event.key !== 'Enter') return;
            const input = event.target.value.trim();
            if (!input) return;
            event.target.value = '';
            
            const [command, ...args] = input.split(' ');
            const arg = args.join(' ');

            if (command === "undo") return postAction('/api/simulation/undo');
            if (command === "redo") return postAction('/api/simulation/redo');
            if (command === "cut" || command === "fiber-cut") return postAction('/api/simulation/fiber-cut', { node_id: arg });
            if (command.startsWith("link-")) return postAction(`/api/links/${arg}/status`, { status: command.split("-")[1] });
            alert(`Unbekannter Befehl: ${command}`);
        }

        document.addEventListener('DOMContentLoaded', initialize);
    </script>
</body>
</html>
